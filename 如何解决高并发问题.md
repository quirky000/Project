# 前言
**高并发**问题是在进行项目开发时能遇到常见问题，在这里对我知道处理的方法进行简单的记录笔记。

## 高并发
概念：通过设计保证系统能够同时**并行**处理**多个**请求。

#### 解决办法
实际上高并发的解决方法无非就是两个方面：硬件和软件。

在硬件方面其实就是最简单的采用**更好**的硬盘，**更好**的内存，**更好**的cpu等等。但是在实际开发过程中，由于各种限制采用这种方法明显十分的**不现实**，所以更加常用和重要的是从**软件**方面解决问题。

##### 方法
1. **系统拆分**

典型的就是采用**dubbo**来实现，通过将一个系统拆分成**多个子系统**，每个子系统各自连接相对应的数据库。这样一来就可以提高对抗高并发的能力。

举个例子：

假设开发一个**电商**项目，将它进行**拆分**：

SSO系统，含：权限系统、卖家系统、买家系统、商品系统等；

库存系统，含：支付系统、发票系统、店铺系统、分账系统等；

评价系统，含：采购系统、物流系统、售后系统等。


2. **缓存**

缓存技术是对抗高并发时会采用的常用手段。实现的方式其实就是在数据库和缓存中写入**一样**的数据，当读取数据时则**从缓存**中读取，由于缓存先于内存与CPU交换数据，速度快，所以它天然抗高并发性就高。

简单而言，就是通过**主动**制造冗余数据，用**空间**换**时间**，从而提高系统可用性。

常用的缓存就例如redis、Nginx等。但是采用缓存技术也会带来**缓存穿透**、**缓存雪崩**、**缓存击穿**、**数据不一致**、**数据竞争**等问题。

3. **消息队列（MQ）**

上文提到的**缓存**技术虽然可以缓解高并发问题，但是也仅限于简单的数据**读写**情况，而一个业务如果涉及频繁的**增删改**数据库的情况下，就无法使用缓存解决，需要使用数据库进行事务的操作。对于这种情况所采取的就是**消息队列（MQ）**。

**消息队列（MQ）** 是一种异步的服务间通信方式，即先将请求**写入队列**进行**排序**，之后逐渐解决具体的请求，这样做就可以将事务操作控制在数据库**可承载范围**之内，借此缓解高并发的情况。

常用的消息队列有：**rocketMQ**、**kafka**等。

4. **读写分离**

数据库处理的请求通常以读写请求居多，那么**读写分离**就是一个不错的解决高并发的方法。

**读写分离**其实就是将数据的**读取**和**写入**分给**复数**个数据库，而这么做数据库的构成一般是**一主多从**（一个主库，多个从库）、**多主多从**（多个主库，多个从库），主库处理**事务性**查询，从库处理**select**查询。当主库数据变动时就会将主库数据**复制**到从库中。通过这种做法能够有效**缓解**服务器的压力，能更加有效对抗**高并发**的情况。

###### 声明
这里我只是进行了简单的记录以供参考，其中可能会有错误在这里欢迎指正。

未来不排除会继续进行更新。